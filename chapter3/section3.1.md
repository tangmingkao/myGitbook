#### Vue 面试题

##### 请说下对响应式数据的理解 ?

所谓响应式数据，是指当数据发生变化时，与该数据关联的视图及时更新。

Vue 是怎么做到这一点的呢？

Vue 通过递归调用 Object.defineProperty()重新定义 data 对象(如果是函数则转成对象)进行观测。Object.defineProperty()重新定义对象的一个属性时，
当属性取值时会触发属性的 getter 函数。当重新设置值时就会触发属性的 setter 函数。做到这一步就做到了对数据变化进行观测。

如何将对象中的数据跟视图中使用的该数据进行关联呢？

Vue 首先会在 Object.defineProperty 观测数据时生成一个依赖收集的 dep 对象，dep 对象会在触发数据的 get 函数时进行依赖收集，会将 watcher 放入 dep 对象的 subs 数组中。
在数据发生变化触发 set 函数时会触发 dep 实例的 notify 方法。notify 方法处理方法是。遍历触发依赖收集数组 subs 里的 wathcer 实例的 update 方法。而每个 wathcer 实例中
的 update 方法其实就是包裹了 Vue 实例的更新视图方法。这样就达到了数据变化触发视图更新。

> 会在生命周期的 mountComponent 方法中实例化 watcher，watcher 实例中会将更新视图的函数挂载在 getter 属性上，并在实例化对象时进行初次渲染。

(ps: 老师，感觉还是没有完全弄透这个步骤，没法用自己的话很清晰的解释)

##### vue 如何检测数组的变化？

vue 检测数组的变化有 2 个方面

1.  数组本身的数据项是通过遍历数组，递归调用 Object.defineProperty()方式实现的。数组的每一项如果是对象，就跟对象一样的方式监测。

2.  数组还要监测改变数组本身的方法。这中情况的监测是通过函数劫持的方法(或者说切片编程思想)。对其中 7 个改变数组本身的原生方法而实现。
    即： 改变数组本身的方法有 'push','pop','shift','unshift','reverse','sort','splice' 这 7 个方法。或者说 vue 只处理了这 7 个方法。
    处理的方式就是：首先通过 Object.create(Array.prototype) 创建一个 arrayMethods 对象。因为式通过数组原型方式创建的，所以该对象通过原型向上游查找，
    是可以找到数组的所有方法的。通过这样的方法就可以创建一个拥有数组所有方法的对象，同时又不污染 Array 对象本身。然后将 arrayMethods 挂载在观测的数组对象的\_\_proto\_\_原型上。
    这样 vue 实例中的数组调用 pop 等数组原生方法时实际上时走 arrayMethods 对象提供的方法。劫持'push','pop','shift','unshift','reverse','sort','splice'这 7 个方法内部实现是：
    首先通过 apply 调用原生数组本身的方法。然后调用视图更新方法。但是数据这 7 中方法中有 3 个函数需要特殊处理因为这三个函数又向数组增加的方法'push','unshift','splice'。可能增加的又是一个对象。这里处理就是通过将这 3 个函数增加的参数再进行观测一遍。跟初始化观测一样。遇到对象就递归观测对象。如果是数组又用观测数组的方法观测一遍。

> 为什么 vue 实例中的数组调用 pop 等数组原生的方法时，走的是 arrayMethods 提供的劫持后的方法呢？

> 因为已经将 arrayMethods 对象挂载在 data 对象的\_\_proto\_\_原型上了。所以 data 对象里的数组调用这些方法时会首先在自己的原型上查找，查找不到才会取 Array 对象上查找。

如何调用视图更新方法？

是因为在 Observer 类的时候，会挂载一个 dep 实例。dep 实例中有 notify 方法进行更新视图。(所以我认为其实对数组的有几个方法并没有观测变化,只是在调用这几个方法后直接更新了一次视图)。

> 为什么可在劫持函数的内部直接调用 Observer 实例的 observeArray 方法？

> Vue 在这里做了一个处理即： 在对某个对象进行观测时，首先会 new 一个 Observer 实例。在 Observer 的构造器会将 this 指向挂载在进行观测的对象的\_\_ob\_\_属性上。这样被观测的对象
> 的\_\_ob\_\_属性上指向的就是 Observer。而在劫持方法中的 this,就是调用该方法的对象。很明显，调用该方法的对象就是被观测的对象。这样被观测的对象就可以通过\_\_ob\_\_属性找到 observeArray 方法。
