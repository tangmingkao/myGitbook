#### Vue 面试题

##### 请说下对响应式数据的理解 ?

所谓响应式数据，是指当数据发生变化时，与该数据关联的视图及时更新。

Vue 是怎么做到这一点的呢？

Vue 通过递归调用 Object.defineProperty()重新定义 data 对象(如果是函数则转成对象)进行观测。Object.defineProperty()重新定义对象的一个属性时，
当属性取值时会触发属性的 getter 函数。当重新设置值时就会触发属性的 setter 函数。做到这一步就做到了对数据变化进行观测。

如何将对象中的数据跟视图中使用的该数据进行关联呢？

Vue 首先会在 Object.defineProperty 观测数据时生成一个依赖收集的 dep 对象，dep 对象会在触发数据的 get 函数时进行依赖收集，会将 watcher 放入 dep 对象的 subs 数组中。
在数据发生变化触发 set 函数时会触发 dep 实例的 notify 方法。notify 方法处理方法是。遍历触发依赖收集数组 subs 里的 wathcer 实例的 update 方法。而每个 wathcer 实例中
的 update 方法其实就是包裹了 Vue 实例的更新视图方法。这样就达到了数据变化触发视图更新。

> 会在生命周期的 mountComponent 方法中实例化 watcher，watcher 实例中会将更新视图的函数挂载在 getter 属性上，并在实例化对象时进行初次渲染。

(ps: 老师，感觉还是没有完全弄透这个步骤，没法用自己的话很清晰的解释)

##### vue 如何检测数组的变化？

vue 检测数组的变化有 2 个方面

1.  数组本身的数据项是通过遍历数组，递归调用 Object.defineProperty()方式实现的。数组的每一项如果是对象，就跟对象一样的方式监测。

2.  数组还要监测改变数组本身的方法。这中情况的监测是通过函数劫持的方法(或者说切片编程思想)。对其中 7 个改变数组本身的原生方法而实现。
    即： 改变数组本身的方法有 'push','pop','shift','unshift','reverse','sort','splice' 这 7 个方法。或者说 vue 只处理了这 7 个方法。
    处理的方式就是：首先通过 Object.create(Array.prototype) 创建一个 arrayMethods 对象。因为式通过数组原型方式创建的，所以该对象通过原型向上游查找，
    是可以找到数组的所有方法的。通过这样的方法就可以创建一个拥有数组所有方法的对象，同时又不污染 Array 对象本身。然后将 arrayMethods 挂载在观测的数组对象的\_\_proto\_\_原型上。
    这样 vue 实例中的数组调用 pop 等数组原生方法时实际上时走 arrayMethods 对象提供的方法。劫持'push','pop','shift','unshift','reverse','sort','splice'这 7 个方法内部实现是：
    首先通过 apply 调用原生数组本身的方法。然后调用视图更新方法。但是数据这 7 中方法中有 3 个函数需要特殊处理因为这三个函数又向数组增加的方法'push','unshift','splice'。可能增加的又是一个对象。这里处理就是通过将这 3 个函数增加的参数再进行观测一遍。跟初始化观测一样。遇到对象就递归观测对象。如果是数组又用观测数组的方法观测一遍。

> 为什么 vue 实例中的数组调用 pop 等数组原生的方法时，走的是 arrayMethods 提供的劫持后的方法呢？

> 因为已经将 arrayMethods 对象挂载在 data 对象的\_\_proto\_\_原型上了。所以 data 对象里的数组调用这些方法时会首先在自己的原型上查找，查找不到才会取 Array 对象上查找。

如何调用视图更新方法？

是因为在 Observer 类的时候，会挂载一个 dep 实例。dep 实例中有 notify 方法进行更新视图。(所以我认为其实对数组的有几个方法并没有观测变化,只是在调用这几个方法后直接更新了一次视图)。

> 为什么可在劫持函数的内部直接调用 Observer 实例的 observeArray 方法？

> Vue 在这里做了一个处理即： 在对某个对象进行观测时，首先会 new 一个 Observer 实例。在 Observer 的构造器会将 this 指向挂载在进行观测的对象的\_\_ob\_\_属性上。这样被观测的对象
> 的\_\_ob\_\_属性上指向的就是 Observer。而在劫持方法中的 this,就是调用该方法的对象。很明显，调用该方法的对象就是被观测的对象。这样被观测的对象就可以通过\_\_ob\_\_属性找到 observeArray 方法。


##### 请说下v-if 和 v-show的区别

v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。

> 注：最好不能将v-if 和 v-for一起使用，因为v-for具有更高的优先级。那么v-if将会重复运行到每个v-for的循环上，造成更高的开销。


##### Vue.use 是干什么的？原理是什么？

安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。该方法需要在调用 new Vue() 之前被调用。当 install 方法被同一个插件多次调用，插件将只会被安装一次。

原理： 

1. 该变量初始值是一个空数组，用来存储已安装过的插件。首先判断传入的插件是否存在于installedPlugins数组中（即已被安装过），如果存在的话，则直接返回，防止重复安装。

2. 接下来获取到传入的其余参数，并且使用toArray方法将其转换成数组，同时将Vue插入到该数组的第一个位置，这是因为在后续调用install方法时，Vue必须作为第一个参数传入。

3. 首先，判断传入的插件如果是一个提供了 install 方法的对象，那么就执行该对象中提供的 install 方法并传入参数完成插件安装。如果传入的插件是一个函数，那么就把这个函数当作install方法执行，同时传入参数完成插件安装。

4. 插件安装完成之后，将该插件添加进已安装插件列表installedPlugins中，防止重复安装。