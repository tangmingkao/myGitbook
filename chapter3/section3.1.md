#### Vue 面试题

##### 请说下对响应式数据的理解 ?

所谓响应式数据，是指当数据发生变化时，与该数据关联的视图及时更新。

Vue 是怎么做到这一点的呢？

Vue 通过递归调用 Object.defineProperty()重新定义 data 对象(如果是函数则转成对象)进行观测。Object.defineProperty()重新定义对象的一个属性时，
当属性取值时会触发属性的 getter 函数。当重新设置值时就会触发属性的 setter 函数。做到这一步就做到了对数据变化进行观测。

如何将对象中的数据跟视图中使用的该数据进行关联呢？

Vue 首先会在 Object.defineProperty 观测数据时生成一个依赖收集的 dep 对象，dep 对象会在触发数据的 get 函数时进行依赖收集，会将 watcher 放入 dep 对象的 subs 数组中。
在数据发生变化触发 set 函数时会触发 dep 实例的 notify 方法。notify 方法处理方法是。遍历触发依赖收集数组 subs 里的 wathcer 实例的 update 方法。而每个 wathcer 实例中
的 update 方法其实就是包裹了 Vue 实例的更新视图方法。这样就达到了数据变化触发视图更新。

> 会在生命周期的 mountComponent 方法中实例化 watcher，watcher 实例中会将更新视图的函数挂载在 getter 属性上，并在实例化对象时进行初次渲染。

(ps: 老师，感觉还是没有完全弄透这个步骤，没法用自己的话很清晰的解释)

###### 答案的参考思路

♥ 核心点考察的是：数组和对象类型当值变化时如何劫持到。对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。 这里在回答时可以带出一些相关知识点（比如多层对象是通过递归来实现劫持，顺带提出 Vue3 中是使用 proxy 来实现响应式数据）

♥ 核心点答出来了也可以在进行补充回答，内部依赖收集是怎样做到的，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher，当属性变化后会通知自己对应的 watcher 去更新 （其实后面会讲到每个对象类型自己本身也拥有一个 dep 属性，这个在\$set 面试题中在进行讲解）

♥ 这里可以引出性能优化相关的内容 （1）对象层级过深，性能就会差 （2）不需要响应数据的内容不要放到 data 中 （3） Object.freeze() 可以冻结数据

##### vue 如何检测数组的变化？

vue 检测数组的变化有 2 个方面

1.  数组本身的数据项是通过遍历数组，递归调用 Object.defineProperty()方式实现的。数组的每一项如果是对象，就跟对象一样的方式监测。

2.  数组还要监测改变数组本身的方法。这中情况的监测是通过函数劫持的方法(或者说切片编程思想)。对其中 7 个改变数组本身的原生方法而实现。
    即： 改变数组本身的方法有 'push','pop','shift','unshift','reverse','sort','splice' 这 7 个方法。或者说 vue 只处理了这 7 个方法。
    处理的方式就是：首先通过 Object.create(Array.prototype) 创建一个 arrayMethods 对象。因为式通过数组原型方式创建的，所以该对象通过原型向上游查找，
    是可以找到数组的所有方法的。通过这样的方法就可以创建一个拥有数组所有方法的对象，同时又不污染 Array 对象本身。然后将 arrayMethods 挂载在观测的数组对象的\_\_proto\_\_原型上。
    这样 vue 实例中的数组调用 pop 等数组原生方法时实际上时走 arrayMethods 对象提供的方法。劫持'push','pop','shift','unshift','reverse','sort','splice'这 7 个方法内部实现是：
    首先通过 apply 调用原生数组本身的方法。然后调用视图更新方法。但是数据这 7 中方法中有 3 个函数需要特殊处理因为这三个函数又向数组增加的方法'push','unshift','splice'。可能增加的又是一个对象。这里处理就是通过将这 3 个函数增加的参数再进行观测一遍。跟初始化观测一样。遇到对象就递归观测对象。如果是数组又用观测数组的方法观测一遍。

> 为什么 vue 实例中的数组调用 pop 等数组原生的方法时，走的是 arrayMethods 提供的劫持后的方法呢？

> 因为已经将 arrayMethods 对象挂载在 data 对象的\_\_proto\_\_原型上了。所以 data 对象里的数组调用这些方法时会首先在自己的原型上查找，查找不到才会取 Array 对象上查找。

如何调用视图更新方法？

是因为在 Observer 类的时候，会挂载一个 dep 实例。dep 实例中有 notify 方法进行更新视图。(所以我认为其实对数组的有几个方法并没有观测变化,只是在调用这几个方法后直接更新了一次视图)。

> 为什么可在劫持函数的内部直接调用 Observer 实例的 observeArray 方法？

> Vue 在这里做了一个处理即： 在对某个对象进行观测时，首先会 new 一个 Observer 实例。在 Observer 的构造器会将 this 指向挂载在进行观测的对象的\_\_ob\_\_属性上。这样被观测的对象
> 的\_\_ob\_\_属性上指向的就是 Observer。而在劫持方法中的 this,就是调用该方法的对象。很明显，调用该方法的对象就是被观测的对象。这样被观测的对象就可以通过\_\_ob\_\_属性找到 observeArray 方法。

###### 答案的参考思路

♥ 核心点考察的是：数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择重写数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写。

♥ 核心点答出来了也可以在进行补充回答，在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新。数组中如果是对象数据类型也会进行递归劫持。

♥ 引发出的问题，那如果想更改索引更新数据怎么办？可以通过 Vue.\$set()来进行处理 =》 核心内部用的是 splice 方法

##### Vue 中的模板编译原理？

模板编译的主要流程是将 html 模板转换成 render 函数。Vue 处理这个的逻辑是：

1. 先查看初始化 Vue 实例的时候是否提供 render 方法，如果提供了就直接用 render 方法。

2. 如果没有提供 render 方法，则查看是否提供模板 template.如果提供了，就将该模板字符串转化成 render 函数

3. 如果即没有提供 render 方法也没有提供 template。则查看是否提供了 el 属性。通过 el 属性查看 HTML 中查找到该元素。如果没查到则直接报错。
   如果查到了，就使用该元素的 outerHTML 获取的字符串作为模板字符串。

4. 获取到了模板字符串，则将该模板字符串通过一系列正则（开始标签，标签名，结束标签等正则）转化成抽象语法树 AST。在这一步利用了 2 中数据结构，栈和树。

5. 标记静态节点为 dom 操作优化做铺垫

6. 通过 AST 语法树生成 code 字符串。然后再利用 with 函数和 new Function 生成 render 函数。

7. 通过 render 函数生成 Vnode 再转化为真实 dom。

##### 生命周期钩子是如何实现的？

生命周期钩子函数的实现是：

1. 初始化的时候调用 mergeOptions 函数进行属性合并。利用策略模式进行不通的合并策略。

2. callHook 函数触发钩子函数。首先从实例的\$options 中获取到需要触发的钩子名称所对应的钩子函数数组 handlers，然后遍历该数组，将数组中的每个钩子函数都执行一遍。
