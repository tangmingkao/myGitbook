### 基本数据结构

#### JS 有 7 种原始数据类型 和 Object 数据类型

原始数据类型 简单数据类型 (原始数据类型都是不可变的,值本身无法被改变)

-   Boolean 布尔表示一个逻辑实体，可以有两个值：true 和 false。
-   Null Null 类型只有一个值： null。
-   Undefined 一个没有被赋值的变量会有个默认值 undefined。
-   Number 根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253 -1) 到 253 -1）。
-   BigInt BigInt 类型是 JavaScript 中的一个基础的数值类型，可以用任意精度表示整数。
-   String JavaScript 的字符串类型用于表示文本数据。它是一组 16 位的无符号整数值的“元素”。
-   Symbol 符号(Symbols)是 ECMAScript 第 6 版新定义的。符号类型是唯一的并且是不可修改的。

Object 数据类型 引用数据类型 在计算机科学中, 对象是指内存中的可以被 标识符引用的一块区域.(如下等)

-   Array
-   Function
-   Date
-   Math
-   RegExp
-   JSON

#### 数据类型和内存

##### JavaScript 引擎的内存空间主要分为栈和堆。

基本类型数据（Number, Boolean, String, Null, Undefined, Symbol, BigInt）保存在在栈内存中。
引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中。也就是说引用数据类型得地址
是存在栈内存中，这个地址是指向堆内存中实际存储的位置。

> 基本类型赋值，系统会为新的变量在栈内存中分配一个新值，这个很好理解。引用类型赋值，系统会为新的变量在栈内存中分配一个值，这个值仅仅是指向同一个对象的引用，和原对象指向的都是堆内存中的同一个对象。

##### 栈

栈是临时存储空间，主要存储局部变量和函数调用。

栈虽然很轻量，在使用时创建，使用结束后销毁，但是不是可以无限增长的，被分配的调用栈空间被占满时，就会引起”栈溢出“的错误。

为什么基本数据类型存储在栈中，引用数据类型存储在堆中？

JavaScript 引擎需要用栈来维护程序执行期间的上下文的状态，如果栈空间大了的话，所有数据都存放在栈空间里面，会影响到上下文切换的效率，进而影响整个程序的执行效率。

##### 堆

堆空间存储的数据比较复杂，大致可以划分为下面 5 个区域：代码区（Code Space）、Map 区(Map Space)、大对象区（Large Object Space）、新生代（New Space）、老生代（Old Space）。

新生代内存是临时分配的内存，存活时间短，老生代内存是常驻内存，存活时间长。

##### 1. null 和 undefined

null 与 undefined 都可以表示“没有”，含义非常相似。将一个变量赋值为 undefined 或 null，老实说，语法效果几乎没区别。
区别是这样的：null 是一个表示“空”的对象，转为数值时为 0；undefined 是一个表示"此处无定义"的原始值，转为数值时为 NaN。

```javascript
Number(undefined); // NaN
Number(null); // 0
```

为什么 typeOf null === 'object' ?

这个 bug 是第一版 Javascript 留下来的。在这个版本，数值是以 32 字节存储的，由标志位（1~3 个字节）和数值组成。标志位存储的是低位的数据。这里有五种标志位：

000：对象，数据是对象的应用。

1：整型，数据是 31 位带符号整数。

010：双精度类型，数据是双精度数字。

100：字符串，数据是字符串。

110：布尔类型，数据是布尔值。

最低位有一位，那么标志位只有一个 1 字节长度；或者是零位，标志位有 3 个字节长度，多出两个了字节，一共多出四种类型。

有两个特殊的数值：

undefined(JSVAL_VOID)是-2^30（一个超出整数范围的数字）
null(JSVAL_NULL)是机器代码的空指针，一个对象类型的引用，值是零。

##### 2. number

JavaScript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。所以，1 与 1.0 是相同的，是同一个数。

```javacript
1 === 1.0 // true
```

这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64 位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把 64 位浮点数，转成 32 位整数，然后再进行运算，参见《运算符》一章的“位运算”部分。

由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。

```javascript
0.1 + 0.2 === 0.3; // false
0.3 / 0.1; // 2.9999999999999996
0.3 - 0.2 === 0.2 - 0.1; // false
```

为什么 0.1 + 0.2 不等于 0.3 ？

计算机内部如何表示数?

计算机用位来储存及处理数据。每一个二进制数（二进制串）都一一对应一个十进制数。

| 十进制 | 进制 | 按位格式 | 描述                                  |
| ------ | ---- | -------- | ------------------------------------- |
| 13     | 10   | 13       | 1x10^1 + 3x10^0 = 10 + 3              |
| 13     | 2    | 1101     | 1x2^3 + 1x2^2 + 0x2^1 1x2^0 = 8+4+0+1 |

计算机内部如何表示小数

| 十进制 | 进制 | 按位格式    | 描述                                    |
| ------ | ---- | ----------- | --------------------------------------- |
| 0.1    | 2    | 0.000110... | 0. 0x2^-1 + 0x2^-2 +0x2^-3 + 1x2^-4 ... |
| 0.2    | 2    | 0.00110...  | 0. 0x2^-1 + 0x2^-2 +1x2^-3 + 1x2^-4 ... |

> 十进制整数转二进制方法：除 2 取余；十进制小数转二进制方法：乘 2 除整

十进制 0.1 转成二进制，乘 2 取整过程

```javascript
0.1 * 2 = 0.2 # 0
0.2 * 2 = 0.4 # 0
0.4 * 2 = 0.8 # 0
0.8 * 2 = 1.6 # 1
0.6 * 2 = 1.2 # 1
0.2 * 2 = 0.4 # 0
.....
```

从上面可以看出，0.1 的二进制格式是：0.0001100011....。这是一个二进制无限循环小数，但计算机内存有限，我们不能用储存所有的小数位数。那么在精度与内存间如何取舍呢？

> IEEE 双精度格式具有 53  位有效数字精度(包含符号号)，并总共占用 64  位。

答案是：在某个精度点直接舍弃。当然，代价就是，0.1 在计算机内部根本就不是精确的 0.1，而是一个有舍入误差的 0.1。当代码被编译或解释后，0.1 已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了。这也就是 0.1 + 0.2 不等于 0.3 的原因。
